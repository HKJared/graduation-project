const exec = require('child_process').exec;
const fs = require('fs');
const cuid = require('cuid');
const colors = require('colors');

exports.stats = false;

exports.compileCPP = function (envData, code, fn) {
    // Creating source file
    const filename = cuid.slug();
    const path = './temp/';

    fs.writeFile(path + filename + '.cpp', code, function (err) {
        if (exports.stats) {
            if (err) console.log('ERROR: '.red + err);
            else {
                // console.log('INFO: '.green + filename + '.cpp created');
                if (envData.cmd === 'g++') {                    
                    // Compile code
                    const command = 'g++ ' + path + filename + '.cpp -o ' + path + filename + '.exe';
                    exec(command, function (error, stdout, stderr) {
                        if (error) {
                            if (exports.stats) {
                                // console.log('INFO: '.green + filename + '.cpp contained an error while compiling');
                            }
                            fn({ error: stderr });
                        } else {
                            let progNotFinished = true;
                            const tempCommand = "cd temp & " + filename;
							
							const startTime = Date.now();
                            exec(tempCommand, function (error, stdout, stderr) {
                                // Stop timing
                                const endTime = Date.now();
                                const executionTime = endTime - startTime;

                                if (error) {
                                    if (error.toString().includes('Error: stdout maxBuffer exceeded.')) {
                                        fn({ error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' });
                                    } else {
                                        if (exports.stats) {
                                            // console.log('INFO: '.green + filename + '.cpp contained an error while executing');
                                        }
                                        fn({ error: stderr });
                                    }
                                } else {
                                    if (progNotFinished) {
                                        progNotFinished = false;
                                        if (exports.stats) {
                                            // console.log('INFO: '.green + filename + '.cpp successfully compiled and executed!');
                                        }
                                        fn({ output: stdout, time: executionTime }); // Return execution time
                                    }
                                }
                            });

                            if (envData.options.timeout) {
                                setTimeout(function () {
                                    exec("taskkill /im " + filename + ".exe /f > nul", function (error, stdout, stderr) {
                                        if (progNotFinished) {
                                            progNotFinished = false;
                                            if (exports.stats) {
                                                // console.log('INFO: '.green + filename + '.exe was killed after ' + envData.options.timeout + 'ms');
                                            }
                                            fn({ timeout: true });
                                        }
                                    });
                                }, envData.options.timeout);
                            }
                        }
                    });
                } else {
                    console.log('ERROR: '.red + 'choose either g++ or gcc');
                }
            }
        }
    });
};

// Compile function with input
exports.compileCPPWithInput = function (envData, code, input, fn) {
    const filename = cuid.slug();
    const path = './temp/';

    fs.writeFile(path + filename + '.cpp', code, function (err) {
        if (exports.stats) {
            if (err) console.log('ERROR: '.red + err);
            else {
                // console.log('INFO: '.green + filename + '.cpp created');
                if (envData.cmd === 'g++') {
                    const command = 'g++ ' + path + filename + '.cpp -o ' + path + filename + '.exe';
                    exec(command, function (error, stdout, stderr) {
                        if (error) {
                            if (exports.stats) {
                                // console.log('INFO: '.green + filename + '.cpp contained an error while compiling');
                            }
                            fn({ error: stderr });
                        } else {
                            if (input) {
                                const inputfile = filename + 'input.txt';
                                fs.writeFile(path + inputfile, input, function (err) {
                                    if (exports.stats) {
                                        if (err) console.log('ERROR: '.red + err);
                                        // else console.log('INFO: '.green + inputfile + ' (inputfile) created');
                                    }
                                });
                                
                                let progNotFinished = true;
                                const tempCommand = "cd temp & " + filename;

								const startTime = Date.now();			
                                exec(tempCommand + ' < ' + inputfile, function (error, stdout, stderr) {
                                    const endTime = Date.now();
                                    const executionTime = endTime - startTime;

                                    if (error) {
                                        if (error.toString().includes('Error: stdout maxBuffer exceeded.')) {
                                            fn({ error: 'Error: stdout maxBuffer exceeded. You might have initialized an infinite loop.' });
                                        } else {
                                            if (exports.stats) {
                                                // console.log('INFO: '.green + filename + '.cpp contained an error while executing');
                                            }
                                            fn({ error: stderr });
                                        }
                                    } else {
                                        if (progNotFinished) {
                                            progNotFinished = false;
                                            if (exports.stats) {
                                                // console.log('INFO: '.green + filename + '.cpp successfully compiled and executed!');
                                            }
                                            fn({ output: stdout, time: executionTime });
                                        }
                                    }
                                });

                                if (envData.options.timeout) {
                                    setTimeout(function () {
                                        exec("taskkill /im " + filename + ".exe /f > nul", function (error, stdout, stderr) {
                                            if (progNotFinished) {
                                                progNotFinished = false;
                                                if (exports.stats) {
                                                    // console.log('INFO: '.green + filename + '.exe was killed after ' + envData.options.timeout + 'ms');
                                                }
                                                fn({ timeout: true });
                                            }
                                        });
                                    }, envData.options.timeout);
                                }
                            } else {
                                if (exports.stats) {
                                    // console.log('INFO: '.green + 'Input missing for ' + filename + '.cpp');
                                }
                                fn({ error: 'Input Missing' });
                            }
                        }
                    });
                } else {
                    console.log('ERROR: '.red + 'choose either g++ or gcc');
                }
            }
        }
    });
};